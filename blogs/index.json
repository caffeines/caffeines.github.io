[{"content":"Git Worktrees: A Powerful Feature for Managing Multiple Working Directories Git worktrees are one of the most underutilized yet powerful features in Git. They allow us to maintain multiple working directories from a single Git repository, each with its own branch checked out. In this blog post, we’ll explore what worktrees are, their benefits, and how to effectively use them in your development workflow.\nWhat is a Git Worktree? A Git worktree is an additional working directory linked to our main repository. Think of it as a way to check out multiple branches simultaneously, each in its own directory, while sharing the same Git history and objects.\nThe main repository (where we run git worktree add) is called the \u0026ldquo;main working tree,\u0026rdquo; and any additional working directories we create are called \u0026ldquo;linked working trees.\u0026rdquo;\nWhen to Use Git Worktree Simultaneous Feature Development: Work on multiple features at once without needing to switch branches. Testing or Reviewing Pull Requests: Test or review a pull request while keeping our current work intact. Bug Fixes: Easily switch between the main branch and bug fix branches without losing progress. Experimentation: Create a separate worktree for experiments, keeping our main branch clean. Managing Legacy Branches: Maintain older versions of our software alongside active development. Easy Comparisons: Compare different branches side by side in separate directories. Reducing Clone Overhead: Avoid multiple clones of a repository; use worktrees to save space. Avoiding Merge Conflicts: Prevent merge conflicts by isolating work on different branches. Git Worktree Concepts Git worktree comes with several options; for this blog, we will focus on git worktree with branch only, as it’s the most common use case. The below commands we will be discussing in this post.\nWorktree Add Worktree List Worktree Remove Git Worktree Add To create a new worktree, use the following command:\ngit worktree add \u0026lt;path\u0026gt; \u0026lt;branch\u0026gt; Let’s assume we have a repository named worktree-demo in the projects folder and we are on a branch named feature:\nprojects/ ├── worktree-demo/ │ ├── .git │ ├── index.html │ ├── main.js Now we will create a new worktree from the worktree-demo repository:\ngit worktree add ../hotfix main This creates a new directory named hotfix with the main branch checked out.\nAfter creating a new worktree, the new project structure will look like this:\nprojects/ ├── worktree-demo/ │ ├── .git │ ├── index.html │ ├── main.js ├── hotfix/ │ ├── .git │ ├── index.html │ ├── main.js Git Worktree List To see all our current worktrees:\ngit worktree list Output:\n/Users/john/Workspace/worktree-demo a7f2163 [feature] /Users/john/Workspace/hotfix a7f2163 [main] Git Worktree Remove When we’re done with a worktree, we can remove it:\ngit worktree remove \u0026lt;path\u0026gt; For example:\n# if you are in hotfix directory (linked worktree) git worktree remove . # if you are in worktree-demo directory (main worktree) git worktree remove ../hotfix After deleting the linked worktree:\nprojects/ ├── worktree-demo/ │ ├── .git │ ├── index.html │ ├── main.js Give Git worktrees a try in your next project, and experience the benefits of this often-overlooked feature!\n","permalink":"https://www.sadat.me/blogs/posts/git/worktree/","summary":"\u003ch1 id=\"git-worktrees-a-powerful-feature-for-managing-multiple-working-directories\"\u003eGit Worktrees: A Powerful Feature for Managing Multiple Working Directories\u003c/h1\u003e\n\u003cp\u003eGit worktrees are one of the most underutilized yet powerful features in Git. They allow us to maintain multiple working directories from a single Git repository, each with its own branch checked out. In this blog post, we’ll explore what worktrees are, their benefits, and how to effectively use them in your development workflow.\u003c/p\u003e\n\u003ch2 id=\"what-is-a-git-worktree\"\u003eWhat is a Git Worktree?\u003c/h2\u003e\n\u003cp\u003eA Git worktree is an additional working directory linked to our main repository. Think of it as a way to check out multiple branches simultaneously, each in its own directory, while sharing the same Git history and objects.\u003c/p\u003e","title":"Git Worktrees"},{"content":"Understanding CPU Latency CPU latency refers to the time it takes for a processor to handle a specific task or instruction. It is the delay between initiating a request and receiving the corresponding output. Lower latency is generally desirable, as it indicates quicker processing and better overall performance in computing tasks. Let’s talk about some common causes of CPU latency.\nInefficient Algorithm Inefficient algorithms can significantly impact CPU latency by prolonging the time it takes to execute tasks. When an inefficient algorithm is used, the CPU has to perform unnecessary or redundant operations, leading to increased processing time. This can result in higher latency, slower response times, and overall reduced system performance. Choosing efficient algorithms is crucial for optimizing CPU usage and minimizing latency in various computing applications.\nContext switching Context switching is the process where the CPU transitions from executing one task (or thread) to another. It involves saving the running task\u0026rsquo;s current state, loading the next task\u0026rsquo;s saved state, and then resuming execution. It’s an illusion of parallel execution in a single CPU.\nContext switching affects CPU latency because it introduces overhead. The time spent on saving and restoring the state of tasks adds to the overall time required to complete a task. Frequent context switches can lead to increased latency and reduced system performance as the CPU spends more time managing these transitions rather than executing the actual tasks. Efficient scheduling and minimizing unnecessary context switches are essential for optimizing CPU latency.\n","permalink":"https://www.sadat.me/blogs/posts/system/cpu/","summary":"\u003ch1 id=\"understanding-cpu-latency\"\u003eUnderstanding CPU Latency\u003c/h1\u003e\n\u003cp\u003eCPU latency refers to the time it takes for a processor to handle a specific task or instruction. It is the delay between initiating a request and receiving the corresponding output. Lower latency is generally desirable, as it indicates quicker processing and better overall performance in computing tasks. Let’s talk about some common causes of CPU latency.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"inefficient-algorithm\"\u003eInefficient Algorithm\u003c/h2\u003e\n\u003cp\u003eInefficient algorithms can significantly impact CPU latency by prolonging the time it takes to execute tasks. When an inefficient algorithm is used, the CPU has to perform unnecessary or redundant operations, leading to increased processing time. This can result in higher latency, slower response times, and overall reduced system performance. Choosing efficient algorithms is crucial for optimizing CPU usage and minimizing latency in various computing applications.\u003c/p\u003e","title":"Understanding CPU Latency"},{"content":"আপনার WhatsApp মেসেজ কীভাবে সুরক্ষিত থাকে: এন্ড-টু-এন্ড এনক্রিপশনের বিস্তারিত ব্যাখ্যা এবং X3DH প্রোটোকলের কার্যকারিতা আমরা প্রতিদিন WhatsApp ব্যবহার করি - ব্যক্তিগত কথা থেকে শুরু করে ব্যবসায়িক আলোচনা, ছবি, ভিডিও, ভয়েস মেসেজ – সবই মুহূর্তে আদান-প্রদান হয়। এই দ্রুত যোগাযোগের যুগে, আমাদের ব্যক্তিগত তথ্য কতটা সুরক্ষিত থাকছে, তা নিয়ে চিন্তা করাটা স্বাভাবিক। আপনার WhatsApp কথোপকথনগুলো কি সত্যিই গোপন থাকে? উত্তরটি হলো, হ্যাঁ, আপনার WhatsApp মেসেজগুলো অত্যন্ত শক্তিশালী \u0026ldquo;এন্ড-টু-এন্ড এনক্রিপশন (End-to-End Encryption)\u0026rdquo; দ্বারা সুরক্ষিত থাকে, যা শুধুমাত্র আপনার এবং আপনার কাঙ্ক্ষিত প্রাপকের মধ্যে গোপনীয়তা নিশ্চিত করে। WhatsApp কর্তৃপক্ষ, ইন্টারনেট সার্ভিস প্রোভাইডার, এমনকি কোনো সরকারও আপনার এনক্রিপ্ট করা মেসেজ পড়তে পারে না।\nএই অবিশ্বাস্য সুরক্ষার পেছনে যে প্রযুক্তি কাজ করে, তার নাম সিগন্যাল প্রোটোকল (Signal Protocol)। আর এই সিগন্যাল প্রোটোকলের একটি অন্যতম গুরুত্বপূর্ণ এবং জটিল অংশ হলো এক্সটেন্ডেড ট্রিপল ডিফি-হেলম্যান (Extended Triple Diffie-Hellman - X3DH) প্রোটোকল। চলুন, ধাপে ধাপে জেনে নেওয়া যাক এই পুরো প্রক্রিয়াটি কীভাবে কাজ করে, এবং X3DH কী ভূমিকা পালন করে।\nএন্ড-টু-এন্ড এনক্রিপশন: মৌলিক ধারণা থেকে গভীরতা এন্ড-টু-এন্ড এনক্রিপশন (E2EE) মানে হল, একটি মেসেজ যখন আপনার ডিভাইস থেকে এনক্রিপ্ট বা সাইফার টেক্সটে রূপান্তরিত হয়, তখন সেই কোডটি একমাত্র রিসিভারের ডিভাইসেই ডিক্রিপ্ট বা প্লেইন টেক্সটে ফিরে আসা সম্ভব। মাঝখানে কেউ এই এনক্রিপ্টেড মেসেজটি পেলেও তার কাছে তা অর্থহীন একগাদা অক্ষর বা সংখ্যা ছাড়া আর কিছুই নয়।\nএই পুরো পদ্ধতির কার্যকারিতার মূলে রয়েছে দুটি প্রধান বিষয়:\nক্রিপ্টোগ্রাফিক কী (Cryptographic Keys): প্রতিটি ব্যবহারকারীর জন্য দুটি ভিন্ন ধরণের চাবি থাকে: পাবলিক কী (Public Key): এটি সর্বজনীন। আপনি এই চাবিটি অন্যদের সাথে শেয়ার করতে পারেন, এবং যে কেউ আপনার জন্য মেসেজ এনক্রিপ্ট করতে এটি ব্যবহার করতে পারে। প্রাইভেট কী (Private Key): এটি একান্তই আপনার নিজস্ব এবং চরম গোপনীয়। এই চাবিটি আপনার ফোনেই সুরক্ষিত থাকে এবং এটি কখনো ফোন থেকে বাইরে যায় না। পাবলিক কী দিয়ে এনক্রিপ্ট করা মেসেজ শুধুমাত্র এর সাথে সংশ্লিষ্ট প্রাইভেট কী দিয়েই ডিক্রিপ্ট করা সম্ভব। সেশন কী (Session Key): এটি হলো একটি অস্থায়ী, একক-ব্যবহারের চাবি যা প্রতিটি নির্দিষ্ট কথোপকথন বা এমনকি প্রতিটি মেসেজের জন্য তৈরি হয়। এটিই আসলে আপনার মেসেজগুলোকে এনক্রিপ্ট এবং ডিক্রিপ্ট করার জন্য ব্যবহৃত হয়। এই সেশন কী-গুলো খুব অল্প সময়ের জন্য ব্যবহৃত হয় এবং তারপর discard করা হয়, যা \u0026ldquo;ফরওয়ার্ড সিক্রেসি\u0026rdquo; নিশ্চিত করে (যা আমরা পরে বিস্তারিত আলোচনা করব)। X3DH প্রোটোকল: সুরক্ষিত সেশন কী তৈরির প্রকৌশল X3DH (Extended Triple Diffie-Hellman) প্রোটোকল হল সেই জটিল কিন্তু অত্যন্ত কার্যকর মেকানিজম যা সেন্ডার এবং রিসিভারের মধ্যে একটি সুরক্ষিত, অভিন্ন সেশন-কী (Session Key) তৈরি করে। এর সবচেয়ে বড় সুবিধা হল, এই কী (Key) তৈরির সময় উভয় পক্ষকে একই সাথে অনলাইনে থাকার প্রয়োজন হয় না। এটি অফলাইন মেসেজিংয়ের ক্ষেত্রেও শক্তিশালী নিরাপত্তা নিশ্চিত করে।\nX3DH এর আগে সাধারণ Diffie-Hellman (DH) প্রোটোকল ব্যবহার করা হতো, যা দুটি পক্ষকে একটি সুরক্ষিত চ্যানেল তৈরি করতে সাহায্য করত। তবে সাধারণ DH এর কিছু সীমাবদ্ধতা ছিল:\nঅ্যাসিনক্রোনাস যোগাযোগ: এটি অফলাইন মেসেজিং সমর্থন করে না। অথেনটিকেশন (Authentication): কে কার সাথে কথা বলছে, তা নিশ্চিত করার জন্য অতিরিক্ত অথেনটিকেশন পদ্ধতি প্রয়োজন। ফরওয়ার্ড সিক্রেসি (Forward Secrecy): যদি দীর্ঘমেয়াদী কোনো চাবি আপোস হয়, তাহলে অতীতের সমস্ত কথোপকথন পড়ে ফেলার ঝুঁকি থাকে। X3DH এই সীমাবদ্ধতাগুলো দূর করে একটি শক্তিশালী, আধুনিক এনক্রিপশন ভিত্তি তৈরি করে। এর জন্য, প্রতিটি ব্যবহারকারীর কাছে একাধিক ধরণের কী থাকে:\nআইডেন্টিটি কী পেয়ার (Identity Key Pair - IK): কাজ: এটি একজন ব্যবহারকারীর স্থায়ী ডিজিটাল পরিচয়। এর পাবলিক অংশ (IK_pub) WhatsApp সার্ভারে আপলোড করা থাকে এবং এটি আপনার প্রোফাইলের সাথে যুক্ত থাকে। প্রাইভেট অংশ (IK_priv) আপনার ডিভাইসেই চরম গোপনীয়ভাবে সংরক্ষিত থাকে। গুরুত্ব: এটি ব্যবহারকারীর পরিচয় অথেনটিকেশনে সহায়তা করে। সাইনড প্রিকী পেয়ার (Signed Pre-key Pair - SPK): কাজ: এটি একটি মধ্যম-মেয়াদী কী পেয়ার (যেমন, এক সপ্তাহ বা এক মাসের জন্য বৈধ)। এর পাবলিক অংশ (SPK_pub) ব্যবহারকারীর IK_priv দ্বারা স্বাক্ষরিত হয়। এই স্বাক্ষরটি প্রমাণ করে যে SPK_pub আসলে ব্যবহারকারীরই এবং এটি কোনোভাবে পরিবর্তন করা হয়নি। গুরুত্ব: এটি অফলাইন অথেনটিকেশনে এবং কী আদান-প্রদানের জন্য ব্যবহৃত হয়। SPK_pub ও এর সাইন (Sign) সার্ভারে আপলোড করা হয়। ওয়ান-টাইম প্রিকী পেয়ার (One-Time Prekey Pair - OPK): কাজ: এটি স্বল্প-মেয়াদী এবং শুধুমাত্র একবার ব্যবহারের জন্য ডিজাইন করা হয়েছে। প্রতিটি ব্যবহারকারী একাধিক OPK_pub তৈরি করে WhatsApp সার্ভারে আপলোড করে রাখে। গুরুত্ব: যখন একজন ব্যবহারকারীকে মেসেজ পাঠানো হয়, তখন সার্ভার এই OPK_pub গুলোর মধ্যে থেকে একটিকে ব্যবহারকারীর কাছে পাঠায় এবং তারপর সেটি সার্ভার থেকে মুছে ফেলে। এটি \u0026ldquo;ফরওয়ার্ড সিক্রেসি\u0026rdquo; এবং অ্যাসিঙ্ক্রোনাস যোগাযোগের জন্য অত্যন্ত গুরুত্বপূর্ণ। এফিমেরাল কী পেয়ার (Ephemeral Key Pair - EK): কাজ: এটি একটি সম্পূর্ণ অস্থায়ী কী পেয়ার, যা প্রতিটি নতুন চ্যাট সেশন শুরু করার সময় সেন্ডার দ্বারা তৈরি হয়। এই EK_pub প্রথম মেসেজের সাথে প্রেরকের কাছে পাঠানো হয়। গুরুত্ব: EK_priv খুব দ্রুত discard করা হয়, যা \u0026ldquo;ফরওয়ার্ড সিক্রেসি\u0026rdquo; নিশ্চিত করতে সাহায্য করে। X3DH প্রোটোকলের কার্যপদ্ধতি (ধাপে ধাপে উদাহরণসহ) ধরুন, আপনি (সুমন) আপনার বন্ধু বিপুল WhatsApp-এ প্রথমবার একটি মেসেজ পাঠাতে চান। বিপুল এই মুহূর্তে অফলাইনে আছেন।\nধাপ ১: বিপুল তার চাবিগুলো সার্ভারে প্রকাশ করে (পূর্ব প্রস্তুতি)\nবিপুল তার ডিভাইস থেকে IK_B (Identity Key Pair), SPK_B (Signed Prekey Pair) এবং একগুচ্ছ OPK_B (One-Time Prekey Pair) তৈরি করে। বিপুল তার IK_B_pub, SPK_B_pub (তার IK_B_priv দ্বারা সাইনড) এবং সমস্ত OPK_B_pub WhatsApp সার্ভারে আপলোড করে রাখে। বিপুল ডিভাইস তখন SPK_B_priv এবং OPK_B_priv এর পাবলিক আপলোড অংশগুলি থেকে মুছে ফেলে, শুধুমাত্র সংশ্লিষ্ট প্রাইভেট কীগুলো নিজের কাছে রাখে। ধাপ ২: সুমন কথোপকথন শুরু করে (মেসেজ পাঠানোর সময়)\nবিপুল তার নিজের IK_A এবং এই বিশেষ চ্যাট সেশনের জন্য একটি নতুন, অস্থায়ী EK_A (Ephemeral Key Pair) তৈরি করে। সুমন WhatsApp সার্ভারের কাছে বিপুল জন্য একটি \u0026ldquo;প্রিকী বান্ডেল\u0026rdquo; রিকুয়েস্ট করে। WhatsApp সার্ভার তখন বিপুলের IK_B_pub, SPK_B_pub ও এর সাইন, এবং একটি অব্যবহৃত OPK_B_pub সুমনের ডিভাইসে পাঠায়। সার্ভার এই OPK_B_pub কে তার তালিকা থেকে মুছে ফেলে। সুমন যাচাই করে: সুমন বিপুলের IK_B_pub ব্যবহার করে SPK_B_pubএর স্বাক্ষর যাচাই করে। যদি সাইন সঠিক হয়, তাহলে সুমনের নিশ্চিত হয় যে বিপুলের কি (Keys) গুলো সঠিক এবং কোনো ম্যান-ইন-দ্য-মিডল (Man-in-the-Middle) আক্রমণ হয়নি। সুমন \u0026ldquo;শেয়ারড সিক্রেট কী (SSK)\u0026rdquo; তৈরি করে: এটিই X3DH এর মূল জাদুকরী অংশ। সুমন তার নিজের প্রাইভেট কী (IK_A_priv, EK_A_priv) এবং বিপুলের প্রাপ্ত পাবলিক কী (IK_B_pub, SPK_B_pub, OPK_B_pub) ব্যবহার করে একাধিক Diffie-Hellman গণনা করে। এই গণনার ফলাফলগুলো একটি শক্তিশালী কী ডেরিভেশন ফাংশন (KDF) এর মাধ্যমে একত্রিত করে একটি অভিন্ন SSK(Shared Secret Key) তৈরি করে। এই SSK কখনো সরাসরি নেটওয়ার্কে আদান-প্রদান হয় না; এটি উভয় প্রান্তে আলাদাভাবে তৈরি হয়। মেসেজ এনক্রিপশন: সুমন তার টাইপ করা মেসেজটিকে (যা প্লেইনটেক্সট) এই সদ্য তৈরি করা SSK ব্যবহার করে এনক্রিপ্ট করে সাইফারটেক্সটে (Ciphertext) রূপান্তরিত করে। এই সাইফারটেক্সটটি এখন একগাদা অর্থহীন অক্ষর এবং সংখ্যার সমষ্টি। সুমন তার IK_A_pub, EK_A_pub এবং যে OPK_B_pub ব্যবহার করেছে তার একটি শনাক্তকারী সহ এনক্রিপ্ট করা মেসেজটি WhatsApp সার্ভারে পাঠায়। সুমন তার EK_A_priv অবিলম্বে মুছে ফেলে। মেসেজ ট্রান্সমিশন এবং ডিক্রিপশন: যাত্রা এবং গন্তব্য মেসেজ ট্রান্সমিশন (প্রেরণ) এনক্রিপ্ট করা মেসেজটি (সাইফারটেক্সট) সুমনের ডিভাইস থেকে বের হয়ে WhatsApp সার্ভারে যায়। WhatsApp সার্ভারের ভূমিকা: এখানে একটি গুরুত্বপূর্ণ বিষয় বোঝা দরকার। WhatsApp সার্ভার এখানে শুধুমাত্র একটি রিলে (Relay) হিসেবে কাজ করে। এর মানে হলো, সার্ভার এনক্রিপ্ট করা মেসেজটি গ্রহণ করে এবং রিসিভারের কাছে পাঠিয়ে দেয়। সার্ভারের কাছে আপনার SSK বা প্রাইভেট কী থাকে না, তাই সার্ভার মেসেজটি ডিক্রিপ্ট বা পড়তে পারে না। এটি শুধুমাত্র একটি সুরক্ষিত পোস্টম্যানের মতো কাজ করে। অফলাইন মেসেজ: যদি রিসিভার অফলাইনে থাকেন, তাহলে এনক্রিপ্ট করা মেসেজটি WhatsApp সার্ভারে সুরক্ষিতভাবে জমা থাকে, যতক্ষণ না রিসিভার অনলাইনে আসেন। এটি অফলাইনে থাকা অবস্থাতেও এনক্রিপ্ট করা থাকে। মেসেজ ডিক্রিপশন (ডিক্রিপ্ট করা) যখন রিসিভারের ডিভাইস এনক্রিপ্ট করা মেসেজটি (সাইফারটেক্সট) পায়, তখন v ডিভাইস তার নিজস্ব SSK ব্যবহার করে। ডিক্রিপশন: বিপুলের ডিভাইস প্রাপ্ত সাইফারটেক্সটকে SSK দিয়ে ডিক্রিপ্ট করে সেটিকে আবার মূল প্লেইনটেক্সট মেসেজে রূপান্তরিত করে। অবশেষে, মেসেজটি বিপুলের স্ক্রিনে প্লেইনটেক্সট রূপে প্রদর্শিত হয়। রিসিভারের ব্যবহৃত OPK_B_priv মুছে ফেলে, যাতে এটি আর ব্যবহার না হয়। X3DH এর নিরাপত্তা বৈশিষ্ট্য ও গুরুত্ব X3DH প্রোটোকল WhatsApp-এর এন্ড-টু-এন্ড এনক্রিপশনকে যে শক্তিশালী নিরাপত্তা বৈশিষ্ট্যগুলো দেয়, সেগুলো হলো:\nফরওয়ার্ড সিক্রেসি (Forward Secrecy - PFS): এটি X3DH এর অন্যতম গুরুত্বপূর্ণ বৈশিষ্ট্য। এর মানে হলো, যদি ভবিষ্যতের কোনো এক সময়ে আপনার দীর্ঘমেয়াদী Identity Key (IK_priv) কোনোভাবে আপোস হয়ে যায়, তাহলেও পূর্বে পাঠানো সমস্ত কথোপকথন ডিক্রিপ্ট করা যাবে না। কারণ প্রতিটি SSK তৈরি হয় অস্থায়ী Ephemeral Key (EK) এবং One-Time Prekey (OPK) এর অবদানে, যা একবার ব্যবহার হওয়ার পর ফেলে দেওয়া হয়। ফলে, পুরনো সেশন কীগুলো পুনরুদ্ধার করা কার্যত অসম্ভব। পোস্ট-কম্প্রোমাইজ সিকিউরিটি (Post-Compromise Security - PCS) / ফিউচার সিক্রেসি: যদি আপনার বর্তমান সেশন কীটি কোনোভাবে আপোস হয়ে যায় (যেমন, হ্যাকিংয়ের মাধ্যমে), তাহলেও ভবিষ্যতের মেসেজগুলো সুরক্ষিত থাকবে। X3DH প্রাথমিক কী তৈরি করে, আর এরপর \u0026ldquo;ডাবল র‍্যাচেট\u0026rdquo; প্রোটোকল এই সুরক্ষা নিশ্চিত করে। মিউচুয়াল অথেনটিকেশন (Mutual Authentication): X3DH নিশ্চিত করে যে উভয় পক্ষই একে অপরের পরিচয় যাচাই করতে পারে। সেন্ডার, রিসিভারের কী (Key) সাইন (Sign) যাচাই করে এবং সেন্ডার, রিসিভারের পাবলিক কী ব্যবহার করে SSK তৈরি করে তার সঠিকতা যাচাই করে। এটি নিশ্চিত করে যে আপনি সঠিক ব্যক্তির সাথেই কথা বলছেন এবং মাঝখানে কোনো অননুমোদিত তৃতীয় পক্ষ নেই। অ্যাসিঙ্ক্রোনাস অপারেশন: X3DH এর অন্যতম বড় সুবিধা হলো, এর প্রিকী (Pre-key) সিস্টেমের কারণে সেন্ডার এবং রিসিভার উভয়কেই একই সময়ে অনলাইনে থাকার প্রয়োজন হয় না। সেন্ডার মেসেজ এনক্রিপ্ট করে পাঠাতে পারে, এমনকি রিসিভার অফলাইনে থাকলেও। যখন রিসিভার অনলাইনে আসবে, তখন সে মেসেজটি ডিক্রিপ্ট করতে পারবে। ডিনায়াবিলিটি (Deniability): যদিও এটি একটি জটিল ধারণা, সহজভাবে বললে, X3DH প্রোটোকলের নকশা এমনভাবে করা হয়েছে যে, কোনো একটি পক্ষ (যেমন, সেন্ডার) পরে অস্বীকার করতে পারে যে সে নির্দিষ্ট কোনো মেসেজ পাঠিয়েছিল, কারণ সে যে কী (Key) দিয়ে মেসেজটি এনক্রিপ্ট করেছে, সেই কী (Key) সে একা তৈরি করেনি, বরং উভয় পক্ষের সহযোগিতায় তৈরি হয়েছে। মেটাডেটা: একটি অন্য দিকের গল্প যদিও WhatsApp আপনার মেসেজের বিষয়বস্তু এন্ড-টু-এন্ড এনক্রিপশনের মাধ্যমে সুরক্ষিত রাখে, তবে একটি গুরুত্বপূর্ণ বিষয় বোঝা দরকার - মেটাডেটা (Metadata)। মেটাডেটা হলো মেসেজের বিষয়বস্তু ছাড়া অন্যান্য তথ্য। যেমন:\nকে কার সাথে কথা বলছে (সেন্ডার ও রিসিভারের আইডি) কখন মেসেজ পাঠানো হয়েছে (সময় ও তারিখ) মেসেজটি গ্রুপ চ্যাটের না ব্যক্তিগত চ্যাটের আপনি কত ঘন ঘন যোগাযোগ করেন আপনার ডিভাইসের ধরণ (অপারেটিং সিস্টেম) এই মেটাডেটাগুলো এনক্রিপ্ট করা হয় না এবং WhatsApp সার্ভার এগুলোর অ্যাক্সেস রাখে। যদিও এটি আপনার মেসেজের বিষয়বস্তু প্রকাশ করে না, তবে প্যাটার্ন বিশ্লেষণ করে আপনার যোগাযোগ অভ্যাস সম্পর্কে ধারণা দিতে পারে। যেমন, যদি সরকার বা কোনো হ্যাকার আপনার মেটাডেটার অ্যাক্সেস পায়, তারা জানতে পারবে আপনি কার সাথে, কখন, কতক্ষণ কথা বলেছেন, যদিও তারা কথার বিষয়বস্তু জানতে পারবে না।\nশেষ কথা WhatsApp-এর এন্ড-টু-এন্ড এনক্রিপশন এবং এর ভিত্তিপ্রস্তর X3DH প্রোটোকল আমাদের ডিজিটাল যোগাযোগের ক্ষেত্রে এক বিপ্লব এনেছে। এটি নিশ্চিত করে যে আপনার সবচেয়ে ব্যক্তিগত মুহূর্তগুলো সুরক্ষিত থাকে। WhatsApp সার্ভার শুধুমাত্র একটি মধ্যস্থতাকারী হিসেবে কাজ করে, এনক্রিপ্ট করা মেসেজগুলো এক ডিভাইস থেকে অন্য ডিভাইসে পাঠিয়ে দেয়, কিন্তু কখনোই তার বিষয়বস্তু জানতে পারে না।\n","permalink":"https://www.sadat.me/blogs/posts/encryption/whatsapp/","summary":"\u003ch1 id=\"আপনর-whatsapp-মসজ-কভব-সরকষত-থক-এনড-ট-এনড-এনকরপশনর-বসতরত-বযখয-এব-x3dh-পরটকলর-করযকরত\"\u003e\u003cstrong\u003eআপনার WhatsApp মেসেজ কীভাবে সুরক্ষিত থাকে: এন্ড-টু-এন্ড এনক্রিপশনের বিস্তারিত ব্যাখ্যা এবং X3DH প্রোটোকলের কার্যকারিতা\u003c/strong\u003e\u003c/h1\u003e\n\u003cp\u003eআমরা প্রতিদিন WhatsApp ব্যবহার করি - ব্যক্তিগত কথা থেকে শুরু করে ব্যবসায়িক আলোচনা, ছবি, ভিডিও, ভয়েস মেসেজ – সবই মুহূর্তে আদান-প্রদান হয়। এই দ্রুত যোগাযোগের যুগে, আমাদের ব্যক্তিগত তথ্য কতটা সুরক্ষিত থাকছে, তা নিয়ে চিন্তা করাটা স্বাভাবিক। আপনার WhatsApp কথোপকথনগুলো কি সত্যিই গোপন থাকে? উত্তরটি হলো, \u003cstrong\u003eহ্যাঁ, আপনার WhatsApp মেসেজগুলো অত্যন্ত শক্তিশালী \u0026ldquo;এন্ড-টু-এন্ড এনক্রিপশন (End-to-End Encryption)\u0026rdquo; দ্বারা সুরক্ষিত থাকে, যা শুধুমাত্র আপনার এবং আপনার কাঙ্ক্ষিত প্রাপকের মধ্যে গোপনীয়তা নিশ্চিত করে।\u003c/strong\u003e WhatsApp কর্তৃপক্ষ, ইন্টারনেট সার্ভিস প্রোভাইডার, এমনকি কোনো সরকারও আপনার এনক্রিপ্ট করা মেসেজ পড়তে পারে না।\u003c/p\u003e","title":"WhatsApp এর এনক্রিপশন প্রসেস"}]